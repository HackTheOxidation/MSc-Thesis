\chapter{Background and Prerequisite Knowledge} \label{sec:background}

In order to get the most out of the thesis, we recommend that the reader is familiar with a quite wide variety of topics.
In this section, we will go through some of the required background and prerequisite knowledge at varying degrees of detail, perhaps only at a glance if 
other sources already provide an appropriate in-depth explanation of well-established knowledge.

The knowledge used in this thesis project spans from rigid maths-based topics such as programming language theory to softer subjects such 
programming paradigms, design patterns and compiler architecture. For some of these topics, the reader is only required to have a basic knowledge. 

\section{Programming Languages and Paradigms}

We recommend that the reader has knowledge of and experience with programming languages and programming paradigms.
That is, we suggest that the reader knows at least one Object-Oriented language, preferably Java, and at least one Functional language,
preferably \texttt{F\#}. This includes knowing the four core principles/the four pillars of Object-Oriented programming:

\begin{enumerate}
\item Abstraction
\item Encapsulation
\item Inheritance
\item Polymorphism
\end{enumerate}

From the Functional programming paradigm, we assume that the reader is familiar with principles such as immutability, referential transparency,
higher-order functions. This roughly corresponds to the curriculum of the course ``02157 - Functional Programming'' at the Technical University of 
Denmark. Advanced Functional Programming concepts such as functors, applicative functors and monads, most notably the Maybe/Option monad and
the Result/Either monad, may be helpful, but not essential to understand the work of this thesis. 

Furthermore, topics from Object-Oriented Design and Architecture such as ``Low-coupling, High cohesion'', ``Gang of Four'' (GoF) design patterns
and the ``SOLID'' principles are also useful to know.

\section{Programming language theory and Compiler Construction}

As this project is mainly about writing a compiler, some knowledge of programming language theory is needed.
Most notably, we recommend a basic understanding of syntax trees, regular expressions and Context-Free Grammars (CFG) from Theory of Computation.
For describing to rules of the Hygge programming language, we recommend a basic understanding of structural operational semantics, substitutions
and inference rules from logic. With regards to type systems, it is helpful to be knowledgable about typing rules and the different
typing disciplines: strong vs. weak, nominal vs. structural and static vs. dynamic.

That is, knowledge corresponding to the curriculum of the course ``02247 - Compiler Construction'' covers all of the mentioned prerequisites.

\section{Java and the JVM ecosystem}

In this section, we introduce the relevant material regarding the Java platform mainly focusing
on the functional language features of ``modern'' Java (version 21 and newer) and the Java Virtual
Machine.

\subsection{Modern Java (JDK 21+)}

When Java was initially released in 1995, it mainly had support for Object-oriented 
programming with language features like classes, objects, 
inheritance in the form of both abstract classes and interfaces and method overloading.
Since Java 8, there has been a shift towards providing support for more Functional 
programming features like anonymous functions (lambdas), higher-order functions, immutable
structures (records), pattern matching and discriminated unions in the form of sealed 
interfaces. We will briefly review a select number of these newer functional features
and compare them to other functional languages.

The most relevant features from newer versions of Java, described in their respective ``Java Enhancement Proposals'' (JEP), which will be used in this thesis, are as follows:

\begin{itemize}
    \item JEP 488 (JDK 24): Primitive Types in Patterns, instanceof, and switch
    \item JEP 484 (JDK 24): Class-File API
    \item JEP 441 (JDK 21): Pattern Matching for switch
    \item JEP 443 (JDK 21): Unnamed Patterns and Variables
    \item JEP 440 (JDK 21): Record Patterns
    \item JEP 395 (JDK 17): Records
    \item JEP 409 (JDK 17): Sealed Classes
\end{itemize}

Some of these JEPs may have predecessor JEPs for earlier releases of Java, but we have omitted those and only referenced the latest refinements. 

\subsection{The Java Virtual Machine (JVM) and JVM bytecode}

The Java platform is more than the Java language. It consists of its own virtual machine,
the Java Virtual Machine (JVM), which can execute ``class''-files with JVM bytecode, among other things.
According to the Java SE 24 ``Java Virtual Machine Specification'', the JVM is an abstract computing machine
and does not assume anything about the underlying hardware platform that it runs on. This is the basis for the
``WORA - Write Once, Run Anywhere'' principle.

The architecture of the JVM is based on a stack machine, where every frame is pushed on and popped from
a stack to perform computations. There are multiple different stacks at play in the JVM, one for each
thread in the JVM, as well as native method stacks. A stack stores frames, which themselves store data
and partial results associated with computation of a method. A frame is created upon method invocation
and destroyed upon method termination no matter the cause (normal or abrupt). Every frame has an array
of local variables (also called local storage), its own operand stack and a reference to the run-time
constant pool of the class of the associated method. A run-time constant pool is a table of constant
values contained within every class for sharing constants among the methods of the class. The JVM
also manages its own heap which is shared among all java virtual threads. Both JVM stacks and the heap
are user configurable; they may either be of a fixed size or dynamic only limited by the memory of
the machine that it runs on.

JVM bytecode is rather simple in the sense that every instruction is only one byte (except for longs and doubles, which are two bytes, or one word).
The bytecode in a ``class''-file is also grouped, first by class then by method, to reflect the structure of the JVM discussed earlier.
To illustrate this, let's go through a small example. In the code snippet below, we show a simple \texttt{Java} program containing a static
\texttt{main()}-method, an instance method and a constructor:

\begin{lstlisting}[language=Java]
class Main {
    private int foo;
    private boolean bar;

    public Main(int foo, boolean bar) {
        this.foo = foo;
        this.bar = bar;
    }

    public void whatTheFoo() {
        if (foo == 42) {
            System.out.println("This is very meaningful!");
        } else {
            System.out.println("This makes no sense at all!");
        }
    }

    public static void main(String[] args) {
        var main = new Main(1, true);
        main.whatTheFoo();
    }
}
\end{lstlisting}

What the code above does is not important. If one then compiles the code with \texttt{javac} (OpenJDK 24.0.0) and then
dissassembles the resulting \texttt{.class}-file with \texttt{javap}, one obtains (depending on JDK release and compiler flags)
the following JVM bytecode in human-readable form:

\begin{lstlisting}
class Main {
  private int foo;

  private boolean bar;

  public Main(int, boolean);
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: iload_1
         6: putfield      #7                  // Field foo:I
         9: aload_0
        10: iload_2
        11: putfield      #13                 // Field bar:Z
        14: return


  public void whatTheFoo();
         0: aload_0
         1: getfield      #7                  // Field foo:I
         4: bipush        42
         6: if_icmpne     20
         9: getstatic     #17                 // Field java/lang/System.out:Ljava/io/PrintStream;
        12: ldc           #23                 // String This is very meaningful!
        14: invokevirtual #25                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        17: goto          28
        20: getstatic     #17                 // Field java/lang/System.out:Ljava/io/PrintStream;
        23: ldc           #31                 // String This makes no sense at all!
        25: invokevirtual #25                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        28: return


  public static void main(java.lang.String[]);
         0: new           #8                  // class Main
         3: dup
         4: iconst_1
         5: iconst_1
         6: invokespecial #33                 // Method "<init>":(IZ)V
         9: astore_1
        10: aload_1
        11: invokevirtual #36                 // Method whatTheFoo:()V
        14: return

}
\end{lstlisting}

Note, that in this example, the run-time constant pool for \texttt{Main} has been removed for the sake of brevity and readability.
Comparing this bytecode with its equivalent \texttt{Java} source program, they are quite similar in terms of structure.
Syntactically, one can say that it is a mix of \texttt{Java} and assembly-like instructions. Every instruction belongs to a
method and every method is part of a class. Notice that a constructor for a class is not that different from a method at
the bytecode level; both constructors and instance methods have a reference to the object at local storage byte offset zero.
The primary difference is that the constructor invokes the \texttt{Object} constructor and calls
for invoking the \texttt{Main} constructor itself must be done using the \texttt{invokespecial} instruction. On the other
hand, calling instance methods and static methods are done using the \texttt{invokevirtual} and \texttt{invokestatic} instructions,
respectively. The hashmarks with numbers, i.e. \#33, are references to the run-time constant pool.
