\chapter{Background and Prerequisite Knowledge} \label{sec:background}

In order to get the most out of the thesis, we recommend that the reader is familiar with a quite wide variety of topics.
In this section, we will go through all of required background and prerequisite knowledge, either in great detail in the case of new insights discovered
as part of the thesis project work, or at a glance if other sources already provide an appropriate in-depth explanation of well-established knowledge.

The knowledge used and discovered in this thesis project spans from rigid math-based topics such as programming language theory to softer subjects such 
programming paradigms, design patterns and compiler architecture with a very concrete and pragmatic approach by being specifically centered around the Java 
ecosystem.

\section{Programming Paradigms and Styles}

Programming languages have evolved substantially since the first programming language came 
to fruition with FORTRAN in 1957. Yet, the operating principles of the underlying hardware 
haven't changed nearly as much. 

Many newer language features provide abstractions and 
programming constructs that have no effect on how the computer processes data, such as
classes, namespaces and modules, but these are still important to programmers as it allows
the programmer to divide the software into logical and coherent components for increased
readability, reduced maintenance and re-usability. Paradigms like Structural programming, 
Procedural Programming and Object-Oriented Programming are examples of ways to associate 
state and behaviour of programs. Other programming features are concerned with how 
computations are performed. 

Most modern processors are built on the fundamental principles of the abstract Turing 
machine, which is a type of state machine. A state machine changes its state, which is the 
essence of Imperative programming; the programmer instructs the computer with commands on
how and when to mutate state. At the other end of the spectrum, Functional programming takes 
a different approach by effectively banning mutability and isolating pure computations from 
side-effects. There is no objectively better way to declare one paradigm as superior to the 
others. Rather, some paradigms are more suitable for certain types of applications and 
problems. 

\subsection{Object-Oriented Programming and Design}

The term Object-oriented programming was first coined by Alan Kay with the introduction of
the SmallTalk language, yet other languages like Simula already had support for OOP features
like classes, inheritance and run-time polymorphism even though the OOP term wasn't commonly
used yet.

\subsection{Functional Programming}

Functional programming has its root in Alonso Churchs Lambda Calculus, which was shown to
be computationally equivalent to a Turing Machine; everything a Turing Machine can compute, 
Lambda Calculus can do the same and vice versa. The defining characteristic of Lambda 
Calculus is that the fundamental unit of abstraction is anonymous functions, or lambdas. 

\section{Java and the JVM ecosystem}

\subsection{Modern Java (JDK 21+)}

When Java was initially released in 1995, it mainly had support for Object-oriented 
programming, which was quite popular at the time, with features like classes, objects, 
inheritance in the form of both abstract classes and interfaces and method overloading.
Since Java 8, there has been a shift towards providing support for more Functional 
programming features like anonymous functions (lambdas), higher-order functions, immutable
structures (records), pattern matching and discriminated unions in the form of sealed 
interfaces. 

\subsection{The Java Virtual Machine (JVM) and JVM bytecode}

\section{Programming language theory}

\subsection{Context-Free Grammars}

\subsection{Parsers}

\subsection{Operational Semantics}

\subsection{Type systems}

\section{Compiler Construction}

\subsection{Architecture and Design}
