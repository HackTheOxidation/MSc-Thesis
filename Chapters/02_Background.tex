\chapter{Background and Prerequisite Knowledge} \label{sec:background}

In order to get the most out of the thesis, we recommend that the reader is familiar with a quite wide variety of topics.
In this section, we will go through some of the required background and prerequisite knowledge at varying degrees of detail, perhaps only at a glance if 
other sources already provide an appropriate in-depth explanation of well-established knowledge.

The knowledge used in this thesis project spans from rigid maths-based topics such as programming language theory to softer subjects such 
programming paradigms, design patterns and compiler architecture. For some of these topics, the reader is only required to have a basic knowledge. 

\section{Programming Languages and Paradigms}

We recommend that the reader has knowledge of and experience with programming languages and programming paradigms.
That is, we suggest that the reader knows at least one Object-Oriented language, preferably Java, and at least one Functional language,
preferably \texttt{F\#}. This includes knowing the four core principles/the four pillars of Object-Oriented programming:

\begin{enumerate}
\item Abstraction
\item Encapsulation
\item Inheritance
\item Polymorphism
\end{enumerate}

From the Functional programming paradigm, we assume that the reader is familiar with principles such as immutability, referential transparency,
higher-order functions. This roughly corresponds to the curriculum of the course ``02157 - Functional Programming'' at the Technical University of 
Denmark. Advanced Functional Programming concepts such as functors, applicative functors and monads, most notably the Maybe/Option monad and
the Result/Either monad, may be helpful, but not essential to understand the work of this thesis. 

Furthermore, topics from Object-Oriented Design and Architecture such as ``Low-coupling, High cohesion'', ``Gang of Four'' (GoF) design patterns
and the ``SOLID'' principles are also useful to know.

\section{Programming language theory and Compiler Construction}

As this project is mainly about writing a compiler, some knowledge of programming language theory is needed.
Most notably, we recommend a basic understanding of syntax trees, regular expressions and Context-Free Grammars (CFG) from Theory of Computation.
For describing to rules of the Hygge programming language, we recommend a basic understanding of structural operational semantics, substitutions
and inference rules from logic. With regards to type systems, it is helpful to be knowledgable about typing rules and the different
typing disciplines: strong vs. weak, nominal vs. structural and static vs. dynamic.

That is, knowledge corresponding to the curriculum of the course ``02247 - Compiler Construction'' covers all of the mentioned prerequisites.

\section{Java and the JVM ecosystem}

In this section, we introduce the relevant material regarding the Java platform mainly focusing
on the functional language features of ``modern'' Java (version 21 and newer) and the Java Virtual
Machine.

\subsection{Modern Java (JDK 21+)}

When Java was initially released in 1995, it mainly had support for Object-oriented 
programming with language features like classes, objects, 
inheritance in the form of both abstract classes and interfaces and method overloading.
Since Java 8, there has been a shift towards providing support for more Functional 
programming features like anonymous functions (lambdas), higher-order functions, immutable
structures (records), pattern matching and discriminated unions in the form of sealed 
interfaces. We will briefly review a select number of these newer functional features
and compare them to other functional languages.

The most relevant features from newer versions of Java, described in their respective ``Java Enhancement Proposals'' (JEP), which will be used in this thesis, are as follows:

\begin{itemize}
    \item JEP 488 (JDK 24): Primitive Types in Patterns, instanceof, and switch
    \item JEP 484 (JDK 24): Class-File API
    \item JEP 441 (JDK 21): Pattern Matching for switch
    \item JEP 443 (JDK 21): Unnamed Patterns and Variables
    \item JEP 440 (JDK 21): Record Patterns
    \item JEP 395 (JDK 17): Records
    \item JEP 409 (JDK 17): Sealed Classes
\end{itemize}

Some of these JEPs may have predecessor JEPs for earlier releases of Java, but we have omitted those and only referenced the latest refinements. 

\subsection{The Java Virtual Machine (JVM) and JVM bytecode}

The Java platform is more than the Java language. It consists of its own virtual machine,
the Java Virtual Machine (JVM), which can execute ``class''-files with JVM bytecode, among other things.
The architecture of the JVM is based on a stack machine, where every frame is pushed on and popped from
a stack to perform computations. There are multiple different stacks at play in the JVM, one for each
thread in the JVM, as well as native method stacks. A stack stores frames, which themselves store data
and partial results associated with computation of a method. A frame is created upon method invocation
and destroyed upon method termination no matter the cause (normal or abrupt). Every frame has an array
of local variables (also called local storage), its own operand stack and a reference to the run-time
constant pool of the class of the associated method. A run-time constant pool is a table of constant
values contained within every class for sharing constants among the methods of the class. The JVM
also manages its own heap which is shared among all java virtual threads. Both JVM stacks and the heap
are user configurable; they may either be of a fixed size, or dynamic only limited by the memory of
the machine that it runs on.

According to the Java SE 24 ``Java Virtual Machine Specification'', the JVM is an abstract computing machine
and does not assume anything about the underlying hardware platform that it runs on. This is the basis for the
``WORA - Write Once, Run Anywhere'' principle.

JVM bytecode is rather simple in the sense that every instruction is only one byte (except for longs and doubles, which are two bytes, or one word).
The bytecode in a ``class''-file is also grouped, first by class, then by method, to reflect the structure of the JVM discussed earlier.
