\chapter{Evaluation}

In this chapter, we discuss the findings and the lessons learned during this MSc Thesis project. We evaluate the final implementation
of the \texttt{JHygge} compiler based on the requirements stated in the \ref{sec:requirements} chapter and the results achieved in
\ref{sec:testing}. Finally, we discuss the goals of this MSc Thesis project and the degree to which they have been achieved.

\section{Does JHygge fulfill the requirements?}

In this section, we discuss the degree to which the new \texttt{JHygge} compiler fulfills the functional and non-functional requirements
stated in figures \ref{fig:functional_requirements} and \ref{fig:nonfunctional_requirements}. In table \ref{table:requirements_fulfillment}, we provide an overview of Hygge language feature support for each of the four compilation phases of
\texttt{JHygge} along with a summary of whether the level of support for a given feature matches that of \texttt{hyggec}.

\begin{table}[H]
\centering
\begin{tabular}{lccccc}
\multicolumn{1}{l|}{}       & \multicolumn{1}{l}{Parsing} & \multicolumn{1}{l}{Typechecker} & \multicolumn{1}{l}{Interpreter} & \multicolumn{1}{l}{Codegen} & \multicolumn{1}{l}{\texttt{hyggec} compatible?} \\ \cline{1-1}
Primitive values             & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Variables                    & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Basic Arithmetic  & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Basic Logic   & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Typing                       & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Let-bindings                 & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Assignments                  & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Assertions                   & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Read and Print I/O           & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
If-Then-Else                 & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Mutable                      & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
While do                     & yes                                & yes                              & yes                                & yes                                & yes                                                              \\
Functions                    & yes                                & yes                              & yes                                & yes                                & yes                                                              \\  
Structs and Fields & yes                                & yes                              & yes                                & yes           & yes                                         \\ 
Unions and \texttt{match}  & yes                                & yes                              & yes                                & no                                 & yes                                                             
\end{tabular}
\caption{Overview of feature support for each of the compilation stages along with a summarizing column showing compatibility with \texttt{hyggec}.}
\label{table:requirements_fulfillment}
\end{table}

Note that although code generation is not supported for unions and pattern matching as shown in Table \ref{table:requirements_fulfillment}, \texttt{JHygge} is still compatible with \texttt{hyggec}
as this is a project option for the students of the course ``02247 - Compiler Construction'' and therefore not supported out-of-box for \texttt{hyggec}
either. Aside from that, the table shows that \texttt{JHygge} implements the same level of support for each feature as \texttt{hyggec}.
When comparing this result with the functional requirements stated in figure \ref{fig:functional_requirements}, this shows fulfillment of all requirements related to support for features of the Hygge language. Administrative-Normal-Form (ANF) and
``peephole'' optimization has not been implemented, but they were also prioritised low as optional extras not essential to the success of \texttt{JHygge}.
Besides, one of the purposes of ANF in \texttt{hyggec} is to optimize register allocation for the RISC-V, where there is a limited number of registers
available, but since the JVM doesn't have the concept of registers this partially justifies assigning it to a lower priority. As for optimization
in general, while it is part of the course curriculum of ``02247 - Compiler Construction'', one could say that this may not be as beneficial,
since the JVM utilitizes a Just-In-Time (JIT) compiler for optimizations at run-time, so some attempts to optimize at compile-time may be in vain.
Optimizations like constant folding and constant propagation would still be usefull, however. As stated, register allocation has not been
implemented as the JVM does not have this concept, so this aligns with the functional requirements.

\subsection{Structural typing on the nominal JVM}

As per the Hygge language specification, the typing system for Hygge is structural. With \texttt{hyggec} it has been shown
that implementing this typing system in RISC-V is possible. The story for the JVM backend in \texttt{JHygge} is somewhat different;
we found that implementing the structural Hygge typing system on the JVM requires some additional layer of abstraction, as
the JVM primarily enforces its own nominal subtyping rules based on inheritance at the bytecode level.
However, the solution turned out to be simple as \texttt{HashMap<String, Object>} provided a suitable abstraction.

In the \texttt{Scala} programming language, it is also possible to imitate structural typing using the trait \texttt{scala.Selectable}, but this is
due to the additional abstractions provided by the \texttt{Scala} standard library and does not change anything about the nominal
type system at the bytecode level of the JVM.

\section{Modern Java is not quite functional, yet}

In this thesis, we have investigated the newer versions of \texttt{Java} specifically with an emphasis on functional programming features.
Although, some of the functional features have been added to the language, \texttt{Java} is still primarily an Object-Oriented language.
It lacks a lot of the more powerful features of other functional languages such as \texttt{Haskell}, \texttt{F\#} and \texttt{Rust},
most notably, functions as first-class citizens, support for monads and functors, algebraic data types.

Regarding monads, the \texttt{Java} standard library does provide the \texttt{Optional} monad, but there are a few problems such as the
fact that it is not implemented as a discriminated union (sealed interface) and thus is not supported by pattern matching in
\texttt{switch}-expressions. Also, instances of \texttt{Optional} are not type-safe as one can still assign \texttt{null} to them.

Another very useful and common monad, which is also used in \texttt{hyggec}, is the \texttt{Result}-monad. This is useful for monadic
and explicit error handling in functional languages, but it is simply lacking in \texttt{Java} 24. Instead, \texttt{Java} relies on
exceptions as its primary way of handling errors. As such, the \texttt{JHygge} implementation relies on exceptions for error handling.
When comparing the implementation of \texttt{JHygge} to that of \texttt{hyggec}, \texttt{hyggec} does make reasonable use of the \texttt{Result}
monad as it is properly supported in \texttt{F\#}. This would have made implementing the typechecking easier. Instead, due to the lack
of \texttt{Result}, we chose to use exceptions instead for the typechecking and (JVM) code-generation phases. Exceptions do produce a
side-effect, which isn't desirable, but it does make the code simpler to understand for students who primarily have experience using
\texttt{Java} in the more common OOP style. As a final note on the \texttt{Result}, while it is not the goal of this thesis to attempt
to ``complete'' support for functional programming features in \texttt{Java}, it is baffling to see that this type has not been implemented
in \texttt{Java} when \texttt{Optional} has. As a minor experiment, a proposed implementation for discriminated union-based \texttt{Result}
monad has been made and it can be found in Appendix \ref{appendix:result_java}.

Furthermore, \texttt{Java} also lacks support for tuples as a built-in data type; this means that one is forced to create small ad-hoc
classes for grouping related data in situations where one does not care about naming a new type. One example of this is \texttt{InterpreterResult},
which only serves the purpose of storing a \texttt{RuntimeEnvironment} and a \texttt{Node}. The same goes for \texttt{LeftRightReductionResult}.
Both of these are single use, single purpose construction whose names are not important.

\section{The Class-file API in action}

Although the previous section evaluating our experiences with \texttt{Java} as a functional programming language came out as rather disappointing,
this section will be a lot more positive as we find that the Java 24 Class-file API to not just work as advertised, but also to provide a
reasonably intuitive and declarative API that leveraged functional programming concepts such as immutability.

\section{A few quantitative points of comparison}

TODO: Compare stats about lines of code.
