\chapter{Evaluation}

In this chapter, we discuss the findings and the lessons learned during this MSc Thesis project. We evaluate the final implementation
of the \texttt{JHygge} compiler based on the requirements stated in the \ref{sec:requirements} chapter and the results achieved in
\ref{sec:testing}. Finally, we discuss the goals of this MSc Thesis project and the degree to which they have been achieved.

\section{Does JHygge fulfill the requirements?}

In this section, we discuss the degree to which the new \texttt{JHygge} compiler fulfills the functional and non-functional requirements
stated in figures \ref{fig:functional_requirements} and \ref{fig:nonfunctional_requirements}.

Note: refer back to requirements and show a table of Hygge features versus compilation phases.

\subsection{Structural typing on the nominal JVM}

As per the Hygge language specification, the typing system for Hygge is structural. With \texttt{hyggec} it has been shown
that implementing this typing system in RISC-V is possible. The story for the JVM backend in \texttt{JHygge} is somewhat different;
we found that implementing the structural Hygge typing system on the JVM requires some additional layer of abstraction, as
the JVM primarily enforces its own nominal subtyping rules based on inheritance at the bytecode level.
However, the solution turned out to be simple as \texttt{HashMap<String, Object>} provided a suitable abstraction.

In the \texttt{Scala} programming language, it is also possible to imitate structural typing using the trait \texttt{scala.Selectable}, but this is
due to the additional abstractions provided by the \texttt{Scala} standard library and does not change anything about the nominal
type system at the bytecode level of the JVM.

\section{Modern Java is not quite functional, yet}

In this thesis, we have investigated the newer versions of \texttt{Java} specifically with an emphasis on functional programming features.
Although, some of the functional features have been added to the language, \texttt{Java} is still primarily an Object-Oriented language.
It lacks a lot of the more powerful features of other functional languages such as \texttt{Haskell}, \texttt{F\#} and \texttt{Rust},
most notably, functions as first-class citizens, support for monads and functors, algebraic data types.

Regarding monads, the \texttt{Java} standard library does provide the \texttt{Optional} monad, but there are a few problems such as the
fact that it is not implemented as a discriminated union (sealed interface) and thus is not supported by pattern matching in
\texttt{switch}-expressions. Also, instances of \texttt{Optional} are not type-safe as one can still assign \texttt{null} to them.

Another very useful and common monad, which is also used in \texttt{hyggec}, is the \texttt{Result}-monad. This is useful for monadic
and explicit error handling in functional languages, but it is simply lacking in \texttt{Java} 24. Instead, \texttt{Java} relies on
exceptions as its primary way of handling errors. As such, the \texttt{JHygge} implementation relies on exceptions for error handling.
When comparing the implementation of \texttt{JHygge} to that of \texttt{hyggec}, \texttt{hyggec} does make reasonable use of the \texttt{Result}
monad as it is properly supported in \texttt{F\#}. This would have made implementing the typechecking easier. Instead, due to the lack
of \texttt{Result}, we chose to use exceptions instead for the typechecking and (JVM) code-generation phases. Exceptions do produce a
side-effect, which isn't desirable, but it does make the code simpler to understand for students who primarily have experience using
\texttt{Java} in the more common OOP style. As a final note on the \texttt{Result}, while it is not the goal of this thesis to attempt
to ``complete'' support for functional programming features in \texttt{Java}, it is baffling to see that this type has not been implemented
in \texttt{Java} when \texttt{Optional} has. As a minor experiment, a proposed implementation for discriminated union-based \texttt{Result}
monad has been made and it can be found in Appendix \ref{appendix:result_java}.

Furthermore, \texttt{Java} also lacks support for tuples as a built-in data type; this means that one is forced to create small ad-hoc
classes for grouping related data in situations where one does not care about naming a new type. One example of this is \texttt{InterpreterResult},
which only serves the purpose of storing a \texttt{RuntimeEnvironment} and a \texttt{Node}. The same goes for \texttt{LeftRightReductionResult}.
Both of these are single use, single purpose construction whose names are not important.

\section{The Class-file API in action}

Although the previous section evaluating our experiences with \texttt{Java} as a functional programming language came out as rather disappointing,
this section will be a lot more positive as we found that the Java 24 Class-file API to not just work as advertised, but also to provide a
reasonably intuitive API that leveraged functional programming concepts such as immutability.

\section{A few quantitative points of comparison}

TODO: Compare stats about lines of code.
